# MyCurrency

MyCurrency is a project that provides currency conversion functionalities using an API based on EUR. This application allows conversion between  EUR, GBP, USD, and CHF. The conversion is performed using data from external APIs, such as Fixer.io.

## Running the Project

To execute the project, follow these steps:

1. Clone the project repository.
2. Navigate to the project directory.
3. Install project dependencies using Poetry:

    ```bash
    poetry install
    ```

4. Activate the virtual environment:

    ```bash
    poetry shell
    ```

5. Navigate to the `mycurrency` folder within the development environment.
6. Perform database migrations:

    ```bash
    python manage.py migrate
    ```

7. Load providers:

    ```bash
    python manage.py update_providers ../test_providers
    ```

8. Load currencies from CSV (Optional):

    ```bash
    python manage.py populate_from_csv ../test_currency_exchange.csv
    ```

9. Create a `.env` file in root with the following structure:

    ```plaintext
    SECRET_KEY="secret-key"
    DEBUG=True
    FIXER_API_KEY="your fixer api key"
    ```

10. Start the development server:

    ```bash
    python manage.py runserver
    ```

After executing these commands, the project should be up and running.


## Testing API Endpoints

### 1. Time Series by Currency

```bash
curl --location 'localhost:8000/api/currency-exchange/timeseries-by-currency/eur/2024-04-04/2024-04-07'
```
This endpoint retrieves the currency exchange rates for EUR between the specified dates.


### 2. Currency Conversion
```bash
curl --location 'localhost:8000/api/currency-exchange/conversion/eur/100/usd/latest'
```

This endpoint converts 100 EUR to USD using the latest exchange rate.


### 3. Time-Weighted Rate of Return (TWRR)
```bash
curl --location 'localhost:8000/api/currency-exchange/twrr/eur/100/usd/2024-04-29'
```

This endpoint calculates the Time-Weighted Rate of Return (TWRR) for converting 100 EUR to USD up to the specified date (2024-04-29).

### 4. Time Series for All Currencies

```bash
curl --location 'localhost:8000/api/currency-exchange/timeseries/2024-04-06/2024-04-08'
```
This endpoint returns the currency exchange rates for all currencies within the specified date range (from 2024-04-06 to 2024-04-08).



## Project Domains

The project is structured into three domains, each responsible for specific functionalities:

### 1. main

The `main` domain contains all project configurations and generic implementations. This domain serves as the central hub for project-wide settings, including database configurations, URL routing, middleware, and any other common functionalities shared across the project.

### 2. currency_exchange

The `currency_exchange` domain handles all aspects related to economic conversions. This includes currency conversion operations, time series data retrieval, and calculations such as Time-Weighted Rate of Return (TWRR).

### 3. broker

The `broker` domain manages any external interactions with third-party services related to MyCurrency. This could involve communication with external APIs like Fixer.io or any other brokerage services used for fetching exchange rates or financial data.


## main Domain

The `main` domain encompasses critical functionalities such as constant implementations, default project error messages, exception handling, and base model implementations.

#### Exception Handler

A simple exception handler has been implemented in `main.utils` to format any errors originating from the API. The code is as follows:

```python
def custom_exception_handler(exc, context):
    response = exception_handler(exc, context)

    if response is not None:
        response.data["status_code"] = response.status_code
    else:
        response = Response(
            {"message": exc.message, "errors": exc.errors, "data": exc.data},
            status=exc.status_code,
        )

    return response
```

This handler manages errors generated by the project itself in the `else` section, while errors from `rest_framework` are handled in the `if` section.

#### Generic Error Messages

A generic error class has been created in `main.error_messages` to structure errors in a more appropriate manner.

#### Base Models

Two models have been created within the `main` domain:

1. Model for data types with codes.
2. Standard model with UUID.

These models will be used throughout the application to extend the models as needed, ensuring project readability and a standardized definition.

## currency_exchange Domain

The `currency_exchange` domain is where the majority of our application's focus lies. Let's first discuss the folder organization:

- **core**: Contains all business logic.
- **data**: Houses actions that interact with the data model.
- **drf**: Defines the interaction pathways of this domain.
- **management**: Contains any tools used for general domain management (e.g., scripts).
- **serialization**: Includes all objects related to data serialization and transfer (DTOs, entities, serializers).
- **admin**: Models for interaction from the Django admin interface.
- **models**: Repository of our models.

#### Models

##### Currency

Represents the information of a currency. In this case, it is configured so that in migration `0001_initial`, default values are loaded, which are EUR, GBP, USD, and CHF.

##### CurrencyExchangeRate

Represents conversions between different currencies for a specific date. It includes a constraint to prevent duplicate entries for source_currency, target_currency, and valuation_date. Note that if we wish to include information about which third-party provider provided this data, this constraint would need to be modified.

For each model, a specific admin interface has been created to allow modifications or changes at any time if necessary.

### API Handling Logic

The `currency_exchange` domain within MyCurrency faced a significant challenge due to the limitations of the test API, Fixer.io, which is severely restricted in its usage under the free version. Given the likelihood of similar constraints on other APIs of this nature, which are typically paid services, it was vital to minimize API usage. Therefore, the following logic has been configured within this domain:

1. **Database Check**: Whenever we access an endpoint, the first step is to check the information stored in the database. If the data for the requested range is present, we use it; otherwise, we fetch it from the API.

2. **Full Data Retrieval**: Since the weight of one API request is not limited to the number of data points it can provide, even if the task only requires information about the EUR currency, all available data will be fetched. Additionally, all possible conversion combinations between currencies will be calculated. Thus, the API will always provide the following information:
    - EUR -> 1.0
    - GBP -> 0.9
    - USD -> 1.1
    - CHF -> 0.8
    
    With this information, all possible conversion combinations based on EUR will be calculated. This allows us to directly store all the information and save the step of conversions in the future.

Later, when we explain the broker domain, we will delve into more detail on how data will be collected from providers like Fixer.

### Endpoint Structure

Whenever a new endpoint is created, the code follows the same structure:

1. **Serialize Input Data**: The input data is serialized using a Django serializer to ensure that the data is valid.

2. **Convert Serializer to DTO**: The serialized data is then converted into a Data Transfer Object (DTO) using Pydantic. This allows for easy manipulation of the data within the service layer.

3. **Call Service**: Next, the appropriate service is called to perform the necessary operations based on the input data.

4. **Prepare Response**: Finally, a response is prepared to return the information using the Response format.

This structured approach ensures consistency and maintainability across different endpoints within the application.


### Service Layer

In the service layer, both `Currency` and `CurrencyExchangeRate` classes will be present, each implementing the necessary business logic for their respective data models. The bulk of the application logic will reside within `CurrencyExchangeRate`.

#### Currency

The `Currency` class handles the business logic related to currency information. It interacts with the repository to save information into the model and retrieve data for the DRF.

#### CurrencyExchangeRate

The `CurrencyExchangeRate` class, as previously mentioned, is responsible for:
1. **Checking Time Series**: This method (`_check_time_series`) ensures that the information retrieved from the database is complete. For example, if we have a date range from 2024-05-05 to 2024-05-07, entries for each date should be present in the database. If any date is missing, it indicates that our model is not up-to-date, and `_get_multiple_exchanges_rates_from_provider` is called.
   
2. **Getting Multiple Exchange Rates from Provider**: This method (`_get_multiple_exchanges_rates_from_provider`) retrieves the missing data not present in our system. It accesses the `broker` module to fetch the necessary information through providers. Once retrieved, it creates entries within the data model and returns them. Additionally, it utilizes the `CurrencyExchangeRateOperations` class to calculate all possible currency conversion combinations for a given date.

While there are other functions within this section for specific tasks, the aforementioned methods are the most important as they have the greatest impact within the application.

### Repositories

Within the repositories for `Currency` and `CurrencyExchangeRate`, the focus is exclusively on executing queries and returning the entities they represent. The repositories follow a minimalist approach, defining base methods such as `_get_queryset`, upon which all other functions base their queries. The goal is to progressively compose functions over others, resulting in a streamlined and efficient codebase.

#### CurrencyRepository

The `CurrencyRepository` class handles queries related to currency information. It defines methods such as `_get_queryset` as the foundation for querying currency data.

#### CurrencyExchangeRateRepository

Similarly, the `CurrencyExchangeRateRepository` class focuses on queries related to currency exchange rates. It follows the same minimalist approach, defining methods like `_get_queryset` as the base for executing queries and returning entities representing currency exchange rates.

This minimalist approach ensures simplicity and maintainability in the repository layer, allowing for easy composition and extension of functions as needed.

### Management Commands

The `management` section has primarily been used for integrating Django commands. In this case, we're discussing data loading for the `CurrencyExchangeRate` model using a CSV file.

#### CSV Format

The CSV format is as follows:

```csv
valuation_date,rates
2023-05-06,"{'USD': '1.076728', 'EUR': 1.00, 'CHF':  0.9, 'GBP':  0.8}"
2023-05-07,"{'USD': '1.076728', 'EUR': 1.00, 'CHF':  0.9, 'GBP':  0.8}"
```

Each row in the CSV file represents a currency exchange rate entry, with the following columns:

- `valuation_date`: The date for which the exchange rates are valid.
- `rates`: A JSON string representing the exchange rates for different currencies.

### Data Loading

Here, we load all the data present in the CSV into the database. If the CSV attempts to update values already present in the database, it would result in a database integrity error during the `bulk_create` operation. However, alternative approaches for handling updates can be implemented with minor modifications.


### Broker Domain

The `broker` domain represents all interactions that MyCurrency will have with third-party services. While currently, the only provider is Fixer, the system is designed to accommodate new providers in the future.

#### Folder Structure

Similar to the `currency_exchange` domain, the `broker` domain follows a folder structure consisting of `core`, `data`, `management`, `serialization`, `admin`, and `models`. However, instead of `drf`, we have `provider` which defines the different third-party apps within the platform and their implementations within the system.

#### Data Model

In the `broker` domain, the data model represents the interactions and configurations related to third-party providers.

### Provider Model

The `Provider` model defines the third-party APIs that our system can connect to. It's important to note that we need to store the necessary environment variables for each provider in the `.env` file.

#### Properties

- **Timeout Property**: This property checks if the provider has an active timeout. The timeout represents whether a provider can be used or not. While active, the provider cannot be used. Timeouts are set for 8 hours and occur when there are issues connecting to the API. If an error occurs, it indicates that there may be a downtime with the provider's system, so we need to look for another provider to operate normally.

- **Priority Order**: The `priority_order` property defines the order in which providers are prioritized. The preference ranges from lower to higher values. This allows us to determine the next provider in the list.

#### ProviderTimeoutQueryset

Additionally, a `ProviderTimeoutQueryset` is created to directly filter all active providers, making it easier for us to handle later operations.

### Service Layer

In the service layer, the most important function is `retrieve()`. This function selects which provider to use by iterating through all providers in the data model that do not have a timeout and are ordered by priority. Each provider is tested one by one until one of them works. If an exception is caught from the provider, a timeout is assigned, and the next provider is tried until a working one is found.

#### Repository

The repository follows the same concept as explained in the `currency_exchange` domain, with two base methods: `_get_queryset` and `_get_queryset_exclude_timeout`. The former retrieves all elements, while the latter filters out those with a timeout.

#### Provider Directory

The `provider` directory consists of two parts:
- **Base Section**: Represents a factory for providers (defined by the API name).
- **BaseProviders**: Defines an abstract class that serves as the basis for specific implementations of different providers. This allows for polymorphism, where each provider inherits general characteristics and implements its own specific features. As only one provider has been worked with, it's assumed that others will also require a list of currency codes and a URL. The URL is currently abstracted to be generic, but specific implementations will be needed based on future provider requirements.

This structure of providers facilitates easy integration of new providers and ensures dynamic state management secured by the database.

#### Management

In the `management` folder, a script has been created to reset the states of providers without needing to stop the application. It expects a CSV with the following format:

```csv
name,priority_order
fixer,1
```

Using `transaction.atomic` to ensure safety, this script recreates the data model with the new provider data. This approach guarantees data integrity by rolling back the changes if any error occurs during the update process. 

This method allows updating the priority order of providers at any time by executing this command. While various approaches could have been taken, such as modifying global variables with a script or directly modifying information from an endpoint or the Django admin, this method was considered the most optimal and secure. It ensures atomicity of the update operation and maintains consistency in the database.



### Final Considerations

Regarding the requested tasks, the back-office visual part has not been implemented due to time constraints during the implementation. However, the provided code demonstrates my programming capabilities.

Similarly, testing has not been implemented for this version of the project for the same reasons mentioned above.

Some namings may not be as ideal as I would like, but unfortunately, I am unable to dedicate more time to clean up the project as much as I would prefer.

Nevertheless, it has been a very interesting challenge reminiscent of my days working on algorithmic trading, where I had to find ways to obtain market information without having the necessary resources. It has been a lot of fun, and I've learned some interesting things along the way. I hope you appreciate my performance and the proposed implementation :)
